// Package screenscraper provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package screenscraper

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for DownloadCompanyMediaParamsOutputformat.
const (
	DownloadCompanyMediaParamsOutputformatJpg DownloadCompanyMediaParamsOutputformat = "jpg"
	DownloadCompanyMediaParamsOutputformatPng DownloadCompanyMediaParamsOutputformat = "png"
)

// Defines values for DownloadGroupMediaParamsOutputformat.
const (
	DownloadGroupMediaParamsOutputformatJpg DownloadGroupMediaParamsOutputformat = "jpg"
	DownloadGroupMediaParamsOutputformatPng DownloadGroupMediaParamsOutputformat = "png"
)

// Defines values for DownloadGameMediaParamsOutputformat.
const (
	DownloadGameMediaParamsOutputformatJpg DownloadGameMediaParamsOutputformat = "jpg"
	DownloadGameMediaParamsOutputformatPng DownloadGameMediaParamsOutputformat = "png"
)

// Defines values for DownloadSystemMediaParamsOutputformat.
const (
	DownloadSystemMediaParamsOutputformatJpg DownloadSystemMediaParamsOutputformat = "jpg"
	DownloadSystemMediaParamsOutputformatPng DownloadSystemMediaParamsOutputformat = "png"
)

// Classification defines model for Classification.
type Classification struct {
	Id        int     `json:"id"`
	Media     []Media `json:"medias,omitempty"`
	NameDE    string  `json:"nom_de,omitempty"`
	NameEN    string  `json:"nom_en,omitempty"`
	NameES    string  `json:"nom_es,omitempty"`
	NameFR    string  `json:"nom_fr,omitempty"`
	NameIT    string  `json:"nom_it,omitempty"`
	NamePT    string  `json:"nom_pt,omitempty"`
	ShortName string  `json:"nomcourt,omitempty"`
	Parent    string  `json:"parent,omitempty"`
}

// ClassificationsListResponse defines model for ClassificationsListResponse.
type ClassificationsListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Classifications map[string]Classification `json:"classifications,omitempty"`
		Servers         ServerInfo                `json:"serveurs,omitempty"`
		User            UserInfo                  `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// DateEntry defines model for DateEntry.
type DateEntry struct {
	Region string `json:"region,omitempty"`
	Text   string `json:"text,omitempty"`
}

// FamiliesListResponse defines model for FamiliesListResponse.
type FamiliesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Families map[string]Family `json:"familles,omitempty"`
		Servers  ServerInfo        `json:"serveurs,omitempty"`
		User     UserInfo          `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// Family defines model for Family.
type Family struct {
	Id    int     `json:"id"`
	Media []Media `json:"medias,omitempty"`
	Name  string  `json:"nom,omitempty"`
}

// Game defines model for Game.
type Game struct {
	Classifications  []GameClassification `json:"classifications,omitempty"`
	CloneOf          string               `json:"cloneof,omitempty"`
	Dates            []DateEntry          `json:"dates,omitempty"`
	Developer        IDText               `json:"developpeur,omitempty"`
	Publisher        IDText               `json:"editeur,omitempty"`
	Families         []GameFamily         `json:"familles,omitempty"`
	Genres           []GameGenre          `json:"genres,omitempty"`
	Id               string               `json:"id"`
	Players          Players              `json:"joueurs,omitempty"`
	Media            []Media              `json:"medias,omitempty"`
	Modes            []GameGenre          `json:"modes,omitempty"`
	Name             string               `json:"nom,omitempty"`
	Names            []NameEntry          `json:"noms,omitempty"`
	Note             Players              `json:"note,omitempty"`
	NotGame          string               `json:"notgame,omitempty"`
	Numbers          []GameGenre          `json:"numeros,omitempty"`
	RegionShortNames []string             `json:"regionshortnames,omitempty"`
	Resolution       string               `json:"resolution,omitempty"`
	Rom              ROM                  `json:"rom,omitempty"`
	ROMID            string               `json:"romid,omitempty"`
	ROMs             []ROM                `json:"roms,omitempty"`
	Rotation         string               `json:"rotation,omitempty"`
	Styles           []GameGenre          `json:"styles,omitempty"`
	Synopsis         []LocalizedName      `json:"synopsis,omitempty"`
	System           SystemInfoRef        `json:"systeme,omitempty"`
	Themes           []GameGenre          `json:"themes,omitempty"`
	TopStaff         string               `json:"topstaff,omitempty"`
}

// GameClassification defines model for GameClassification.
type GameClassification struct {
	Text string `json:"text,omitempty"`
	Type string `json:"type,omitempty"`
}

// GameFamily defines model for GameFamily.
type GameFamily struct {
	Id        string          `json:"id,omitempty"`
	ShortName string          `json:"nomcourt,omitempty"`
	Names     []LocalizedName `json:"noms,omitempty"`
	ParentID  string          `json:"parentid,omitempty"`
	Primary   string          `json:"principale,omitempty"`
}

// GameGenre defines model for GameGenre.
type GameGenre struct {
	Id        string          `json:"id,omitempty"`
	ShortName string          `json:"nomcourt,omitempty"`
	Names     []LocalizedName `json:"noms,omitempty"`
	ParentID  string          `json:"parentid,omitempty"`
	Primary   string          `json:"principale,omitempty"`
}

// GameInfoResponse defines model for GameInfoResponse.
type GameInfoResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Game    Game       `json:"jeu,omitempty"`
		Servers ServerInfo `json:"serveurs,omitempty"`
		User    UserInfo   `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// GameInfoType defines model for GameInfoType.
type GameInfoType struct {
	AutoGen       string `json:"autogen,omitempty"`
	Category      string `json:"categorie,omitempty"`
	Id            int    `json:"id"`
	MultiChoice   string `json:"multichoix,omitempty"`
	MultiRegions  string `json:"multiregions,omitempty"`
	MultiSupports string `json:"multisupports,omitempty"`
	MultiVersions string `json:"multiversions,omitempty"`
	Name          string `json:"nom,omitempty"`
	ShortName     string `json:"nomcourt,omitempty"`
	Platforms     string `json:"plateforms,omitempty"`
	PlatformTypes string `json:"plateformtypes,omitempty"`
	Type          string `json:"type,omitempty"`
}

// GameInfoTypesListResponse defines model for GameInfoTypesListResponse.
type GameInfoTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Info    map[string]GameInfoType `json:"infos,omitempty"`
		Servers ServerInfo              `json:"serveurs,omitempty"`
		User    UserInfo                `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// GameMediaTypesListResponse defines model for GameMediaTypesListResponse.
type GameMediaTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Media   map[string]MediaType `json:"medias,omitempty"`
		Servers ServerInfo           `json:"serveurs,omitempty"`
		User    UserInfo             `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// GameSearchResponse defines model for GameSearchResponse.
type GameSearchResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Games   []Game     `json:"jeux,omitempty"`
		Servers ServerInfo `json:"serveurs,omitempty"`
		User    UserInfo   `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// Genre defines model for Genre.
type Genre struct {
	Id        int     `json:"id"`
	Media     []Media `json:"medias,omitempty"`
	NameDE    string  `json:"nom_de,omitempty"`
	NameEN    string  `json:"nom_en,omitempty"`
	NameES    string  `json:"nom_es,omitempty"`
	NameFR    string  `json:"nom_fr,omitempty"`
	NameIT    string  `json:"nom_it,omitempty"`
	NamePT    string  `json:"nom_pt,omitempty"`
	ShortName string  `json:"nomcourt,omitempty"`
	Parent    string  `json:"parent,omitempty"`
}

// GenresListResponse defines model for GenresListResponse.
type GenresListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Genres  map[string]Genre `json:"genres,omitempty"`
		Servers ServerInfo       `json:"serveurs,omitempty"`
		User    UserInfo         `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// Header defines model for Header.
type Header struct {
	APIversion       string `json:"APIversion,omitempty"`
	CommandRequested string `json:"commandRequested,omitempty"`
	DateTime         string `json:"dateTime,omitempty"`
	Error            string `json:"error,omitempty"`
	Success          string `json:"success,omitempty"`
}

// IDText defines model for IDText.
type IDText struct {
	Id   string `json:"id,omitempty"`
	Text string `json:"text,omitempty"`
}

// InfraInfoResponse defines model for InfraInfoResponse.
type InfraInfoResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Servers ServerInfo `json:"serveurs,omitempty"`
	} `json:"response,omitempty"`
}

// Language defines model for Language.
type Language struct {
	Id        int     `json:"id"`
	Media     []Media `json:"medias,omitempty"`
	NameDE    string  `json:"nom_de,omitempty"`
	NameEN    string  `json:"nom_en,omitempty"`
	NameES    string  `json:"nom_es,omitempty"`
	NameFR    string  `json:"nom_fr,omitempty"`
	NameIT    string  `json:"nom_it,omitempty"`
	NamePT    string  `json:"nom_pt,omitempty"`
	ShortName string  `json:"nomcourt,omitempty"`
	Parent    string  `json:"parent,omitempty"`
}

// LanguagesListResponse defines model for LanguagesListResponse.
type LanguagesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Languages map[string]Language `json:"langues,omitempty"`
		Servers   ServerInfo          `json:"serveurs,omitempty"`
		User      UserInfo            `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// LocalizedName defines model for LocalizedName.
type LocalizedName struct {
	Language string `json:"langue,omitempty"`
	Text     string `json:"text,omitempty"`
}

// Media defines model for Media.
type Media struct {
	Crc     string `json:"crc,omitempty"`
	Format  string `json:"format,omitempty"`
	Md5     string `json:"md5,omitempty"`
	Parent  string `json:"parent,omitempty"`
	Region  string `json:"region,omitempty"`
	Sha1    string `json:"sha1,omitempty"`
	Size    string `json:"size,omitempty"`
	Support string `json:"support,omitempty"`
	Type    string `json:"type"`
	Url     string `json:"url"`
}

// MediaType defines model for MediaType.
type MediaType struct {
	AutoGen       string `json:"autogen,omitempty"`
	Category      string `json:"categorie,omitempty"`
	ExtraInfoText string `json:"extrainfostxt,omitempty"`
	FileFormat    string `json:"fileformat,omitempty"`
	FileFormat2   string `json:"fileformat2,omitempty"`
	Id            int    `json:"id"`
	MultiRegions  string `json:"multiregions,omitempty"`
	MultiSupports string `json:"multisupports,omitempty"`
	MultiVersions string `json:"multiversions,omitempty"`
	Name          string `json:"nom,omitempty"`
	ShortName     string `json:"nomcourt,omitempty"`
	Platforms     string `json:"plateforms,omitempty"`
	PlatformTypes string `json:"plateformtypes,omitempty"`
	Type          string `json:"type,omitempty"`
}

// NameEntry defines model for NameEntry.
type NameEntry struct {
	Region string `json:"region,omitempty"`
	Text   string `json:"text,omitempty"`
}

// PlayerCount defines model for PlayerCount.
type PlayerCount struct {
	Id     int    `json:"id"`
	Name   string `json:"nom,omitempty"`
	Parent string `json:"parent,omitempty"`
}

// PlayerCountsListResponse defines model for PlayerCountsListResponse.
type PlayerCountsListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		PlayerCounts map[string]PlayerCount `json:"nbjoueurs,omitempty"`
		Servers      ServerInfo             `json:"serveurs,omitempty"`
		User         UserInfo               `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// Players defines model for Players.
type Players struct {
	Text string `json:"text,omitempty"`
}

// ROM defines model for ROM.
type ROM struct {
	Alternate        string     `json:"alt,omitempty"`
	Best             string     `json:"best,omitempty"`
	Beta             string     `json:"beta,omitempty"`
	Demo             string     `json:"demo,omitempty"`
	Hack             string     `json:"hack,omitempty"`
	Id               string     `json:"id"`
	ScrapCount       string     `json:"nbscrap,omitempty"`
	Netplay          string     `json:"netplay,omitempty"`
	Prototype        string     `json:"proto,omitempty"`
	Regions          ROMRegions `json:"regions,omitempty"`
	ROMCloneOf       string     `json:"romcloneof,omitempty"`
	ROMCRC           string     `json:"romcrc,omitempty"`
	ROMFilename      string     `json:"romfilename,omitempty"`
	ROMMD5           string     `json:"rommd5,omitempty"`
	ROMSupportNumber string     `json:"romnumsupport,omitempty"`
	ROMSHA1          string     `json:"romsha1,omitempty"`
	ROMSize          string     `json:"romsize,omitempty"`
	ROMSupportTotal  string     `json:"romtotalsupport,omitempty"`
	Translation      string     `json:"trad,omitempty"`
	Unlicensed       string     `json:"unl,omitempty"`
}

// ROMRegions defines model for ROMRegions.
type ROMRegions struct {
	RegionsDE        []string `json:"regions_de,omitempty"`
	RegionsEN        []string `json:"regions_en,omitempty"`
	RegionsES        []string `json:"regions_es,omitempty"`
	RegionsFR        []string `json:"regions_fr,omitempty"`
	RegionsID        []string `json:"regions_id,omitempty"`
	RegionsPT        []string `json:"regions_pt,omitempty"`
	RegionsShortName []string `json:"regions_shortname,omitempty"`
}

// Region defines model for Region.
type Region struct {
	Id        int          `json:"id"`
	Media     RegionMedias `json:"medias,omitempty"`
	NameDE    string       `json:"nom_de,omitempty"`
	NameEN    string       `json:"nom_en,omitempty"`
	NameES    string       `json:"nom_es,omitempty"`
	NameFR    string       `json:"nom_fr,omitempty"`
	NameIT    string       `json:"nom_it,omitempty"`
	NamePT    string       `json:"nom_pt,omitempty"`
	ShortName string       `json:"nomcourt,omitempty"`
	Parent    string       `json:"parent,omitempty"`
}

// RegionMedias defines model for RegionMedias.
type RegionMedias struct {
	MediaBackground         string `json:"media_background,omitempty"`
	MediaColorPicto         string `json:"media_pictocouleur,omitempty"`
	MediaColorPictoSVG      string `json:"media_pictocouleursvg,omitempty"`
	MediaMonochromePicto    string `json:"media_pictomonochrome,omitempty"`
	MediaMonochromePictoSVG string `json:"media_pictomonochromesvg,omitempty"`
}

// RegionsListResponse defines model for RegionsListResponse.
type RegionsListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Regions map[string]Region `json:"regions,omitempty"`
		Servers ServerInfo        `json:"serveurs,omitempty"`
		User    UserInfo          `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// RomInfoType defines model for RomInfoType.
type RomInfoType struct {
	AutoGen       string `json:"autogen,omitempty"`
	Category      string `json:"categorie,omitempty"`
	Id            int    `json:"id"`
	MultiChoice   string `json:"multichoix,omitempty"`
	MultiRegions  string `json:"multiregions,omitempty"`
	MultiSupports string `json:"multisupports,omitempty"`
	MultiVersions string `json:"multiversions,omitempty"`
	Name          string `json:"nom,omitempty"`
	ShortName     string `json:"nomcourt,omitempty"`
	Platforms     string `json:"plateforms,omitempty"`
	PlatformTypes string `json:"plateformtypes,omitempty"`
	Type          string `json:"type,omitempty"`
}

// RomInfoTypesListResponse defines model for RomInfoTypesListResponse.
type RomInfoTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Info    map[string]RomInfoType `json:"infos,omitempty"`
		Servers ServerInfo             `json:"serveurs,omitempty"`
		User    UserInfo               `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// RomTypesListResponse defines model for RomTypesListResponse.
type RomTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		ROMTypes []string   `json:"romtypes,omitempty"`
		Servers  ServerInfo `json:"serveurs,omitempty"`
		User     UserInfo   `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// ServerInfo defines model for ServerInfo.
type ServerInfo struct {
	APIAccess             string `json:"apiacces,omitempty"`
	ClosedForLeecher      string `json:"closeforleecher,omitempty"`
	ClosedForNonMember    string `json:"closefornomember,omitempty"`
	Cpu1                  string `json:"cpu1,omitempty"`
	Cpu2                  string `json:"cpu2,omitempty"`
	Cpu3                  string `json:"cpu3,omitempty"`
	Cpu4                  string `json:"cpu4,omitempty"`
	MaxThreadForMember    string `json:"maxthreadformember,omitempty"`
	MaxThreadForNonMember string `json:"maxthreadfornonmember,omitempty"`
	ScraperCount          string `json:"nbscrapeurs,omitempty"`
	ThreadForMember       string `json:"threadformember,omitempty"`
	ThreadForNonMember    string `json:"threadfornonmember,omitempty"`
	MinThreads            string `json:"threadsmin,omitempty"`
}

// SupportTypesListResponse defines model for SupportTypesListResponse.
type SupportTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Servers      ServerInfo `json:"serveurs,omitempty"`
		User         UserInfo   `json:"ssuser,omitempty"`
		SupportTypes []string   `json:"supporttypes,omitempty"`
	} `json:"response,omitempty"`
}

// System defines model for System.
type System struct {
	Company     string            `json:"compagnie,omitempty"`
	StartDate   string            `json:"datedebut,omitempty"`
	EndDate     string            `json:"datefin,omitempty"`
	Extensions  string            `json:"extensions,omitempty"`
	Id          int               `json:"id"`
	Media       []Media           `json:"medias,omitempty"`
	Names       map[string]string `json:"noms,omitempty"`
	ParentID    int               `json:"parentid,omitempty"`
	ROMType     string            `json:"romtype,omitempty"`
	SupportType string            `json:"supporttype,omitempty"`
	Type        string            `json:"type,omitempty"`
}

// SystemInfoRef defines model for SystemInfoRef.
type SystemInfoRef struct {
	Id   string `json:"id,omitempty"`
	Text string `json:"text,omitempty"`
}

// SystemMediaTypesListResponse defines model for SystemMediaTypesListResponse.
type SystemMediaTypesListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Media   map[string]MediaType `json:"medias,omitempty"`
		Servers ServerInfo           `json:"serveurs,omitempty"`
		User    UserInfo             `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// SystemsListResponse defines model for SystemsListResponse.
type SystemsListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Servers ServerInfo `json:"serveurs,omitempty"`
		User    UserInfo   `json:"ssuser,omitempty"`
		Systems []System   `json:"systemes,omitempty"`
	} `json:"response,omitempty"`
}

// UserInfo defines model for UserInfo.
type UserInfo struct {
	Contribution            string `json:"contribution,omitempty"`
	LastVisitDate           string `json:"datedernierevisite,omitempty"`
	FavoriteRegion          string `json:"favregion,omitempty"`
	Id                      string `json:"id,omitempty"`
	MaxDownloadSpeed        string `json:"maxdownloadspeed,omitempty"`
	MaxFailedRequestsPerDay string `json:"maxrequestskoperday,omitempty"`
	MaxRequestsPerDay       string `json:"maxrequestsperday,omitempty"`
	MaxRequestsPerMin       string `json:"maxrequestspermin,omitempty"`
	MaxThreads              string `json:"maxthreads,omitempty"`
	Level                   string `json:"niveau,omitempty"`
	NumID                   string `json:"numid,omitempty"`
	RejectedProposals       string `json:"propositionko,omitempty"`
	ApprovedProposals       string `json:"propositionok,omitempty"`
	RefusedQuota            string `json:"quotarefu,omitempty"`
	FailedRequestsToday     string `json:"requestskotoday,omitempty"`
	RequestsToday           string `json:"requeststoday,omitempty"`
	ROMAssociation          string `json:"romasso,omitempty"`
	InfoUpload              string `json:"uploadinfos,omitempty"`
	MediaUpload             string `json:"uploadmedia,omitempty"`
	SystemUpload            string `json:"uploadsysteme,omitempty"`
	Visits                  string `json:"visites,omitempty"`
}

// UserInfoResponse defines model for UserInfoResponse.
type UserInfoResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Servers ServerInfo `json:"serveurs,omitempty"`
		User    UserInfo   `json:"ssuser,omitempty"`
	} `json:"response,omitempty"`
}

// UserLevel defines model for UserLevel.
type UserLevel struct {
	Id     int    `json:"id"`
	NameFR string `json:"nom_fr,omitempty"`
}

// UserLevelsListResponse defines model for UserLevelsListResponse.
type UserLevelsListResponse struct {
	Header   Header `json:"header,omitempty"`
	Response struct {
		Servers    ServerInfo           `json:"serveurs,omitempty"`
		User       UserInfo             `json:"ssuser,omitempty"`
		UserLevels map[string]UserLevel `json:"userlevels,omitempty"`
	} `json:"response,omitempty"`
}

// SubmitRatingParams defines parameters for SubmitRating.
type SubmitRatingParams struct {
	// GameID Numeric game ID
	GameID string `form:"gameid" json:"gameid"`

	// Rating Rating score (1-20)
	Rating int `form:"note" json:"note"`
}

// SubmitProposalMultipartBody defines parameters for SubmitProposal.
type SubmitProposalMultipartBody struct {
	// GameID Target game ID (mutually exclusive with romid)
	GameID string `json:"gameid,omitempty"`

	// ModifyLanguage Language for info proposals
	ModifyLanguage string `json:"modiflangue,omitempty"`

	// ModifyMediaFile File upload for media proposals
	ModifyMediaFile openapi_types.File `json:"modifmediafile,omitempty"`

	// ModifyMediaFileURL URL of media (alternative to file upload)
	ModifyMediaFileURL string `json:"modifmediafileurl,omitempty"`

	// ModifyRegion Region for info proposals
	ModifyRegion string `json:"modifregion,omitempty"`

	// ModifySource Source reference
	ModifySource string `json:"modifsource,omitempty"`

	// ModifyText Text content for info proposals
	ModifyText string `json:"modiftexte,omitempty"`

	// ModifyInfoType Info type for text proposals
	ModifyInfoType string `json:"modiftypeinfo,omitempty"`

	// ModifyMediaType Media type for media proposals
	ModifyMediaType string `json:"modiftypemedia,omitempty"`

	// ModifySupportNumber Support number (0-10)
	ModifySupportNumber string `json:"modiftypenumsupport,omitempty"`

	// ModifyTypeRegion Region for media proposals
	ModifyTypeRegion string `json:"modiftyperegion,omitempty"`
	ModifyVersion    string `json:"modifversion,omitempty"`

	// ROMID Target ROM ID (mutually exclusive with gameid)
	ROMID string `json:"romid,omitempty"`

	// UserID User ID
	UserID string `json:"ssid,omitempty"`

	// UserPassword User password
	UserPassword string `json:"sspassword,omitempty"`
}

// GetGameInfoParams defines parameters for GetGameInfo.
type GetGameInfoParams struct {
	// Crc CRC32 hash of ROM file
	Crc string `form:"crc,omitempty" json:"crc,omitempty"`

	// Md5 MD5 hash of ROM file
	Md5 string `form:"md5,omitempty" json:"md5,omitempty"`

	// Sha1 SHA1 hash of ROM file
	Sha1 string `form:"sha1,omitempty" json:"sha1,omitempty"`

	// ROMSize ROM size in bytes
	ROMSize string `form:"romtaille,omitempty" json:"romtaille,omitempty"`

	// SystemID Numeric system ID
	SystemID string `form:"systemeid,omitempty" json:"systemeid,omitempty"`

	// ROMType Type of ROM: rom, iso, or folder
	ROMType string `form:"romtype,omitempty" json:"romtype,omitempty"`

	// ROMName ROM filename with extension
	ROMName string `form:"romnom,omitempty" json:"romnom,omitempty"`

	// GameID Direct game lookup by numeric ID
	GameID string `form:"gameid,omitempty" json:"gameid,omitempty"`

	// SerialNumber Serial number for ISO identification
	SerialNumber string `form:"serialnum,omitempty" json:"serialnum,omitempty"`
}

// SearchGamesParams defines parameters for SearchGames.
type SearchGamesParams struct {
	// SearchQuery Search query string
	SearchQuery string `form:"recherche" json:"recherche"`

	// SystemID Limit search to specific system
	SystemID string `form:"systemeid,omitempty" json:"systemeid,omitempty"`
}

// DownloadCompanyMediaParams defines parameters for DownloadCompanyMedia.
type DownloadCompanyMediaParams struct {
	// CompanyID Numeric company ID
	CompanyID    string                                 `form:"companyid" json:"companyid"`
	Media        string                                 `form:"media" json:"media"`
	Crc          string                                 `form:"crc,omitempty" json:"crc,omitempty"`
	Md5          string                                 `form:"md5,omitempty" json:"md5,omitempty"`
	Sha1         string                                 `form:"sha1,omitempty" json:"sha1,omitempty"`
	MediaFormat  string                                 `form:"mediaformat,omitempty" json:"mediaformat,omitempty"`
	MaxWidth     string                                 `form:"maxwidth,omitempty" json:"maxwidth,omitempty"`
	MaxHeight    string                                 `form:"maxheight,omitempty" json:"maxheight,omitempty"`
	OutputFormat DownloadCompanyMediaParamsOutputformat `form:"outputformat,omitempty" json:"outputformat,omitempty"`
}

// DownloadCompanyMediaParamsOutputformat defines parameters for DownloadCompanyMedia.
type DownloadCompanyMediaParamsOutputformat string

// DownloadGroupMediaParams defines parameters for DownloadGroupMedia.
type DownloadGroupMediaParams struct {
	// GroupID Numeric group ID
	GroupID      string                               `form:"groupid" json:"groupid"`
	Media        string                               `form:"media" json:"media"`
	Crc          string                               `form:"crc,omitempty" json:"crc,omitempty"`
	Md5          string                               `form:"md5,omitempty" json:"md5,omitempty"`
	Sha1         string                               `form:"sha1,omitempty" json:"sha1,omitempty"`
	MediaFormat  string                               `form:"mediaformat,omitempty" json:"mediaformat,omitempty"`
	MaxWidth     string                               `form:"maxwidth,omitempty" json:"maxwidth,omitempty"`
	MaxHeight    string                               `form:"maxheight,omitempty" json:"maxheight,omitempty"`
	OutputFormat DownloadGroupMediaParamsOutputformat `form:"outputformat,omitempty" json:"outputformat,omitempty"`
}

// DownloadGroupMediaParamsOutputformat defines parameters for DownloadGroupMedia.
type DownloadGroupMediaParamsOutputformat string

// DownloadGameMediaParams defines parameters for DownloadGameMedia.
type DownloadGameMediaParams struct {
	SystemID string `form:"systemeid" json:"systemeid"`

	// GameID Game ID
	GameID string `form:"jeuid" json:"jeuid"`

	// Media Media identifier (e.g., "box-2D(us)", "wheel-hd(eu)")
	Media string `form:"media" json:"media"`

	// Crc Hash for deduplication
	Crc          string                              `form:"crc,omitempty" json:"crc,omitempty"`
	Md5          string                              `form:"md5,omitempty" json:"md5,omitempty"`
	Sha1         string                              `form:"sha1,omitempty" json:"sha1,omitempty"`
	MediaFormat  string                              `form:"mediaformat,omitempty" json:"mediaformat,omitempty"`
	MaxWidth     string                              `form:"maxwidth,omitempty" json:"maxwidth,omitempty"`
	MaxHeight    string                              `form:"maxheight,omitempty" json:"maxheight,omitempty"`
	OutputFormat DownloadGameMediaParamsOutputformat `form:"outputformat,omitempty" json:"outputformat,omitempty"`
}

// DownloadGameMediaParamsOutputformat defines parameters for DownloadGameMedia.
type DownloadGameMediaParamsOutputformat string

// DownloadSystemMediaParams defines parameters for DownloadSystemMedia.
type DownloadSystemMediaParams struct {
	SystemID     string                                `form:"systemeid" json:"systemeid"`
	Media        string                                `form:"media" json:"media"`
	Crc          string                                `form:"crc,omitempty" json:"crc,omitempty"`
	Md5          string                                `form:"md5,omitempty" json:"md5,omitempty"`
	Sha1         string                                `form:"sha1,omitempty" json:"sha1,omitempty"`
	MediaFormat  string                                `form:"mediaformat,omitempty" json:"mediaformat,omitempty"`
	MaxWidth     string                                `form:"maxwidth,omitempty" json:"maxwidth,omitempty"`
	MaxHeight    string                                `form:"maxheight,omitempty" json:"maxheight,omitempty"`
	OutputFormat DownloadSystemMediaParamsOutputformat `form:"outputformat,omitempty" json:"outputformat,omitempty"`
}

// DownloadSystemMediaParamsOutputformat defines parameters for DownloadSystemMedia.
type DownloadSystemMediaParamsOutputformat string

// SubmitProposalMultipartRequestBody defines body for SubmitProposal for multipart/form-data ContentType.
type SubmitProposalMultipartRequestBody SubmitProposalMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubmitRating request
	SubmitRating(ctx context.Context, params *SubmitRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitProposalWithBody request with any body
	SubmitProposalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClassifications request
	ListClassifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFamilies request
	ListFamilies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGenres request
	ListGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGameInfoTypes request
	ListGameInfoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRomInfoTypes request
	ListRomInfoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameInfo request
	GetGameInfo(ctx context.Context, params *GetGameInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGames request
	SearchGames(ctx context.Context, params *SearchGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLanguages request
	ListLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadCompanyMedia request
	DownloadCompanyMedia(ctx context.Context, params *DownloadCompanyMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGroupMedia request
	DownloadGroupMedia(ctx context.Context, params *DownloadGroupMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadGameMedia request
	DownloadGameMedia(ctx context.Context, params *DownloadGameMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadSystemMedia request
	DownloadSystemMedia(ctx context.Context, params *DownloadSystemMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGameMediaTypes request
	ListGameMediaTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSystemMediaTypes request
	ListSystemMediaTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlayerCounts request
	ListPlayerCounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegions request
	ListRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRomTypes request
	ListRomTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfraInfo request
	GetInfraInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserInfo request
	GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSupportTypes request
	ListSupportTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSystems request
	ListSystems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserLevels request
	ListUserLevels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SubmitRating(ctx context.Context, params *SubmitRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitRatingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitProposalWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitProposalRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClassifications(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClassificationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFamilies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFamiliesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGenres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGenresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGameInfoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGameInfoTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRomInfoTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRomInfoTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameInfo(ctx context.Context, params *GetGameInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGames(ctx context.Context, params *SearchGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLanguages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLanguagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadCompanyMedia(ctx context.Context, params *DownloadCompanyMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadCompanyMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGroupMedia(ctx context.Context, params *DownloadGroupMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGroupMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadGameMedia(ctx context.Context, params *DownloadGameMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadGameMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadSystemMedia(ctx context.Context, params *DownloadSystemMediaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadSystemMediaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGameMediaTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGameMediaTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSystemMediaTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSystemMediaTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlayerCounts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlayerCountsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRomTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRomTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfraInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfraInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSupportTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSupportTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSystems(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSystemsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserLevels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserLevelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSubmitRatingRequest generates requests for SubmitRating
func NewSubmitRatingRequest(server string, params *SubmitRatingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/botNote.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameid", runtime.ParamLocationQuery, params.GameID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "note", runtime.ParamLocationQuery, params.Rating); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitProposalRequestWithBody generates requests for SubmitProposal with any type of body
func NewSubmitProposalRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/botProposition.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListClassificationsRequest generates requests for ListClassifications
func NewListClassificationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/classificationsListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFamiliesRequest generates requests for ListFamilies
func NewListFamiliesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/famillesListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGenresRequest generates requests for ListGenres
func NewListGenresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genresListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGameInfoTypesRequest generates requests for ListGameInfoTypes
func NewListGameInfoTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/infosJeuListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRomInfoTypesRequest generates requests for ListRomInfoTypes
func NewListRomInfoTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/infosRomListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameInfoRequest generates requests for GetGameInfo
func NewGetGameInfoRequest(server string, params *GetGameInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jeuInfos.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crc", runtime.ParamLocationQuery, params.Crc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "md5", runtime.ParamLocationQuery, params.Md5); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha1", runtime.ParamLocationQuery, params.Sha1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "romtaille", runtime.ParamLocationQuery, params.ROMSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemeid", runtime.ParamLocationQuery, params.SystemID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "romtype", runtime.ParamLocationQuery, params.ROMType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "romnom", runtime.ParamLocationQuery, params.ROMName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gameid", runtime.ParamLocationQuery, params.GameID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serialnum", runtime.ParamLocationQuery, params.SerialNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchGamesRequest generates requests for SearchGames
func NewSearchGamesRequest(server string, params *SearchGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jeuRecherche.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recherche", runtime.ParamLocationQuery, params.SearchQuery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemeid", runtime.ParamLocationQuery, params.SystemID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLanguagesRequest generates requests for ListLanguages
func NewListLanguagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/languesListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadCompanyMediaRequest generates requests for DownloadCompanyMedia
func NewDownloadCompanyMediaRequest(server string, params *DownloadCompanyMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediaCompagnie.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "companyid", runtime.ParamLocationQuery, params.CompanyID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media", runtime.ParamLocationQuery, params.Media); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crc", runtime.ParamLocationQuery, params.Crc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "md5", runtime.ParamLocationQuery, params.Md5); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha1", runtime.ParamLocationQuery, params.Sha1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaformat", runtime.ParamLocationQuery, params.MediaFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxwidth", runtime.ParamLocationQuery, params.MaxWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxheight", runtime.ParamLocationQuery, params.MaxHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputformat", runtime.ParamLocationQuery, params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadGroupMediaRequest generates requests for DownloadGroupMedia
func NewDownloadGroupMediaRequest(server string, params *DownloadGroupMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediaGroup.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groupid", runtime.ParamLocationQuery, params.GroupID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media", runtime.ParamLocationQuery, params.Media); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crc", runtime.ParamLocationQuery, params.Crc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "md5", runtime.ParamLocationQuery, params.Md5); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha1", runtime.ParamLocationQuery, params.Sha1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaformat", runtime.ParamLocationQuery, params.MediaFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxwidth", runtime.ParamLocationQuery, params.MaxWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxheight", runtime.ParamLocationQuery, params.MaxHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputformat", runtime.ParamLocationQuery, params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadGameMediaRequest generates requests for DownloadGameMedia
func NewDownloadGameMediaRequest(server string, params *DownloadGameMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediaJeu.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemeid", runtime.ParamLocationQuery, params.SystemID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jeuid", runtime.ParamLocationQuery, params.GameID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media", runtime.ParamLocationQuery, params.Media); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crc", runtime.ParamLocationQuery, params.Crc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "md5", runtime.ParamLocationQuery, params.Md5); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha1", runtime.ParamLocationQuery, params.Sha1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaformat", runtime.ParamLocationQuery, params.MediaFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxwidth", runtime.ParamLocationQuery, params.MaxWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxheight", runtime.ParamLocationQuery, params.MaxHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputformat", runtime.ParamLocationQuery, params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadSystemMediaRequest generates requests for DownloadSystemMedia
func NewDownloadSystemMediaRequest(server string, params *DownloadSystemMediaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediaSysteme.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "systemeid", runtime.ParamLocationQuery, params.SystemID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "media", runtime.ParamLocationQuery, params.Media); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crc", runtime.ParamLocationQuery, params.Crc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "md5", runtime.ParamLocationQuery, params.Md5); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha1", runtime.ParamLocationQuery, params.Sha1); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mediaformat", runtime.ParamLocationQuery, params.MediaFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxwidth", runtime.ParamLocationQuery, params.MaxWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxheight", runtime.ParamLocationQuery, params.MaxHeight); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outputformat", runtime.ParamLocationQuery, params.OutputFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGameMediaTypesRequest generates requests for ListGameMediaTypes
func NewListGameMediaTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediasJeuListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSystemMediaTypesRequest generates requests for ListSystemMediaTypes
func NewListSystemMediaTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mediasSystemeListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlayerCountsRequest generates requests for ListPlayerCounts
func NewListPlayerCountsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nbJoueursListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRegionsRequest generates requests for ListRegions
func NewListRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/regionsListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRomTypesRequest generates requests for ListRomTypes
func NewListRomTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/romTypesListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfraInfoRequest generates requests for GetInfraInfo
func NewGetInfraInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssinfraInfos.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserInfoRequest generates requests for GetUserInfo
func NewGetUserInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ssuserInfos.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSupportTypesRequest generates requests for ListSupportTypes
func NewListSupportTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/supportTypesListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSystemsRequest generates requests for ListSystems
func NewListSystemsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/systemesListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserLevelsRequest generates requests for ListUserLevels
func NewListUserLevelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/userlevelsListe.php")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubmitRatingWithResponse request
	SubmitRatingWithResponse(ctx context.Context, params *SubmitRatingParams, reqEditors ...RequestEditorFn) (*SubmitRatingResponse, error)

	// SubmitProposalWithBodyWithResponse request with any body
	SubmitProposalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitProposalResponse, error)

	// ListClassificationsWithResponse request
	ListClassificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClassificationsResponse, error)

	// ListFamiliesWithResponse request
	ListFamiliesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFamiliesResponse, error)

	// ListGenresWithResponse request
	ListGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGenresResponse, error)

	// ListGameInfoTypesWithResponse request
	ListGameInfoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGameInfoTypesResponse, error)

	// ListRomInfoTypesWithResponse request
	ListRomInfoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRomInfoTypesResponse, error)

	// GetGameInfoWithResponse request
	GetGameInfoWithResponse(ctx context.Context, params *GetGameInfoParams, reqEditors ...RequestEditorFn) (*GetGameInfoResponse, error)

	// SearchGamesWithResponse request
	SearchGamesWithResponse(ctx context.Context, params *SearchGamesParams, reqEditors ...RequestEditorFn) (*SearchGamesResponse, error)

	// ListLanguagesWithResponse request
	ListLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLanguagesResponse, error)

	// DownloadCompanyMediaWithResponse request
	DownloadCompanyMediaWithResponse(ctx context.Context, params *DownloadCompanyMediaParams, reqEditors ...RequestEditorFn) (*DownloadCompanyMediaResponse, error)

	// DownloadGroupMediaWithResponse request
	DownloadGroupMediaWithResponse(ctx context.Context, params *DownloadGroupMediaParams, reqEditors ...RequestEditorFn) (*DownloadGroupMediaResponse, error)

	// DownloadGameMediaWithResponse request
	DownloadGameMediaWithResponse(ctx context.Context, params *DownloadGameMediaParams, reqEditors ...RequestEditorFn) (*DownloadGameMediaResponse, error)

	// DownloadSystemMediaWithResponse request
	DownloadSystemMediaWithResponse(ctx context.Context, params *DownloadSystemMediaParams, reqEditors ...RequestEditorFn) (*DownloadSystemMediaResponse, error)

	// ListGameMediaTypesWithResponse request
	ListGameMediaTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGameMediaTypesResponse, error)

	// ListSystemMediaTypesWithResponse request
	ListSystemMediaTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSystemMediaTypesResponse, error)

	// ListPlayerCountsWithResponse request
	ListPlayerCountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlayerCountsResponse, error)

	// ListRegionsWithResponse request
	ListRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error)

	// ListRomTypesWithResponse request
	ListRomTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRomTypesResponse, error)

	// GetInfraInfoWithResponse request
	GetInfraInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfraInfoResponse, error)

	// GetUserInfoWithResponse request
	GetUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error)

	// ListSupportTypesWithResponse request
	ListSupportTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSupportTypesResponse, error)

	// ListSystemsWithResponse request
	ListSystemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSystemsResponse, error)

	// ListUserLevelsWithResponse request
	ListUserLevelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserLevelsResponse, error)
}

type SubmitRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitProposalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SubmitProposalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitProposalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClassificationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationsListResponse
}

// Status returns HTTPResponse.Status
func (r ListClassificationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClassificationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFamiliesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FamiliesListResponse
}

// Status returns HTTPResponse.Status
func (r ListFamiliesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFamiliesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GenresListResponse
}

// Status returns HTTPResponse.Status
func (r ListGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGameInfoTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameInfoTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListGameInfoTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGameInfoTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRomInfoTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RomInfoTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListRomInfoTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRomInfoTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetGameInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameSearchResponse
}

// Status returns HTTPResponse.Status
func (r SearchGamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LanguagesListResponse
}

// Status returns HTTPResponse.Status
func (r ListLanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadCompanyMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadCompanyMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadCompanyMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGroupMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGroupMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGroupMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadGameMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadGameMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadGameMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadSystemMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadSystemMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadSystemMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGameMediaTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GameMediaTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListGameMediaTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGameMediaTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSystemMediaTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemMediaTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListSystemMediaTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSystemMediaTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlayerCountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlayerCountsListResponse
}

// Status returns HTTPResponse.Status
func (r ListPlayerCountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlayerCountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegionsListResponse
}

// Status returns HTTPResponse.Status
func (r ListRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRomTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RomTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListRomTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRomTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfraInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InfraInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetInfraInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfraInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserInfoResponse
}

// Status returns HTTPResponse.Status
func (r GetUserInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSupportTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportTypesListResponse
}

// Status returns HTTPResponse.Status
func (r ListSupportTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSupportTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SystemsListResponse
}

// Status returns HTTPResponse.Status
func (r ListSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserLevelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserLevelsListResponse
}

// Status returns HTTPResponse.Status
func (r ListUserLevelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserLevelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubmitRatingWithResponse request returning *SubmitRatingResponse
func (c *ClientWithResponses) SubmitRatingWithResponse(ctx context.Context, params *SubmitRatingParams, reqEditors ...RequestEditorFn) (*SubmitRatingResponse, error) {
	rsp, err := c.SubmitRating(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitRatingResponse(rsp)
}

// SubmitProposalWithBodyWithResponse request with arbitrary body returning *SubmitProposalResponse
func (c *ClientWithResponses) SubmitProposalWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitProposalResponse, error) {
	rsp, err := c.SubmitProposalWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitProposalResponse(rsp)
}

// ListClassificationsWithResponse request returning *ListClassificationsResponse
func (c *ClientWithResponses) ListClassificationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClassificationsResponse, error) {
	rsp, err := c.ListClassifications(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClassificationsResponse(rsp)
}

// ListFamiliesWithResponse request returning *ListFamiliesResponse
func (c *ClientWithResponses) ListFamiliesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListFamiliesResponse, error) {
	rsp, err := c.ListFamilies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFamiliesResponse(rsp)
}

// ListGenresWithResponse request returning *ListGenresResponse
func (c *ClientWithResponses) ListGenresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGenresResponse, error) {
	rsp, err := c.ListGenres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGenresResponse(rsp)
}

// ListGameInfoTypesWithResponse request returning *ListGameInfoTypesResponse
func (c *ClientWithResponses) ListGameInfoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGameInfoTypesResponse, error) {
	rsp, err := c.ListGameInfoTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGameInfoTypesResponse(rsp)
}

// ListRomInfoTypesWithResponse request returning *ListRomInfoTypesResponse
func (c *ClientWithResponses) ListRomInfoTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRomInfoTypesResponse, error) {
	rsp, err := c.ListRomInfoTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRomInfoTypesResponse(rsp)
}

// GetGameInfoWithResponse request returning *GetGameInfoResponse
func (c *ClientWithResponses) GetGameInfoWithResponse(ctx context.Context, params *GetGameInfoParams, reqEditors ...RequestEditorFn) (*GetGameInfoResponse, error) {
	rsp, err := c.GetGameInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGameInfoResponse(rsp)
}

// SearchGamesWithResponse request returning *SearchGamesResponse
func (c *ClientWithResponses) SearchGamesWithResponse(ctx context.Context, params *SearchGamesParams, reqEditors ...RequestEditorFn) (*SearchGamesResponse, error) {
	rsp, err := c.SearchGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGamesResponse(rsp)
}

// ListLanguagesWithResponse request returning *ListLanguagesResponse
func (c *ClientWithResponses) ListLanguagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLanguagesResponse, error) {
	rsp, err := c.ListLanguages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLanguagesResponse(rsp)
}

// DownloadCompanyMediaWithResponse request returning *DownloadCompanyMediaResponse
func (c *ClientWithResponses) DownloadCompanyMediaWithResponse(ctx context.Context, params *DownloadCompanyMediaParams, reqEditors ...RequestEditorFn) (*DownloadCompanyMediaResponse, error) {
	rsp, err := c.DownloadCompanyMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadCompanyMediaResponse(rsp)
}

// DownloadGroupMediaWithResponse request returning *DownloadGroupMediaResponse
func (c *ClientWithResponses) DownloadGroupMediaWithResponse(ctx context.Context, params *DownloadGroupMediaParams, reqEditors ...RequestEditorFn) (*DownloadGroupMediaResponse, error) {
	rsp, err := c.DownloadGroupMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGroupMediaResponse(rsp)
}

// DownloadGameMediaWithResponse request returning *DownloadGameMediaResponse
func (c *ClientWithResponses) DownloadGameMediaWithResponse(ctx context.Context, params *DownloadGameMediaParams, reqEditors ...RequestEditorFn) (*DownloadGameMediaResponse, error) {
	rsp, err := c.DownloadGameMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadGameMediaResponse(rsp)
}

// DownloadSystemMediaWithResponse request returning *DownloadSystemMediaResponse
func (c *ClientWithResponses) DownloadSystemMediaWithResponse(ctx context.Context, params *DownloadSystemMediaParams, reqEditors ...RequestEditorFn) (*DownloadSystemMediaResponse, error) {
	rsp, err := c.DownloadSystemMedia(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadSystemMediaResponse(rsp)
}

// ListGameMediaTypesWithResponse request returning *ListGameMediaTypesResponse
func (c *ClientWithResponses) ListGameMediaTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListGameMediaTypesResponse, error) {
	rsp, err := c.ListGameMediaTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGameMediaTypesResponse(rsp)
}

// ListSystemMediaTypesWithResponse request returning *ListSystemMediaTypesResponse
func (c *ClientWithResponses) ListSystemMediaTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSystemMediaTypesResponse, error) {
	rsp, err := c.ListSystemMediaTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSystemMediaTypesResponse(rsp)
}

// ListPlayerCountsWithResponse request returning *ListPlayerCountsResponse
func (c *ClientWithResponses) ListPlayerCountsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListPlayerCountsResponse, error) {
	rsp, err := c.ListPlayerCounts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlayerCountsResponse(rsp)
}

// ListRegionsWithResponse request returning *ListRegionsResponse
func (c *ClientWithResponses) ListRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRegionsResponse, error) {
	rsp, err := c.ListRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegionsResponse(rsp)
}

// ListRomTypesWithResponse request returning *ListRomTypesResponse
func (c *ClientWithResponses) ListRomTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRomTypesResponse, error) {
	rsp, err := c.ListRomTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRomTypesResponse(rsp)
}

// GetInfraInfoWithResponse request returning *GetInfraInfoResponse
func (c *ClientWithResponses) GetInfraInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfraInfoResponse, error) {
	rsp, err := c.GetInfraInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfraInfoResponse(rsp)
}

// GetUserInfoWithResponse request returning *GetUserInfoResponse
func (c *ClientWithResponses) GetUserInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserInfoResponse, error) {
	rsp, err := c.GetUserInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserInfoResponse(rsp)
}

// ListSupportTypesWithResponse request returning *ListSupportTypesResponse
func (c *ClientWithResponses) ListSupportTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSupportTypesResponse, error) {
	rsp, err := c.ListSupportTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSupportTypesResponse(rsp)
}

// ListSystemsWithResponse request returning *ListSystemsResponse
func (c *ClientWithResponses) ListSystemsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSystemsResponse, error) {
	rsp, err := c.ListSystems(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSystemsResponse(rsp)
}

// ListUserLevelsWithResponse request returning *ListUserLevelsResponse
func (c *ClientWithResponses) ListUserLevelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserLevelsResponse, error) {
	rsp, err := c.ListUserLevels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserLevelsResponse(rsp)
}

// ParseSubmitRatingResponse parses an HTTP response from a SubmitRatingWithResponse call
func ParseSubmitRatingResponse(rsp *http.Response) (*SubmitRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSubmitProposalResponse parses an HTTP response from a SubmitProposalWithResponse call
func ParseSubmitProposalResponse(rsp *http.Response) (*SubmitProposalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitProposalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListClassificationsResponse parses an HTTP response from a ListClassificationsWithResponse call
func ParseListClassificationsResponse(rsp *http.Response) (*ListClassificationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClassificationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFamiliesResponse parses an HTTP response from a ListFamiliesWithResponse call
func ParseListFamiliesResponse(rsp *http.Response) (*ListFamiliesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFamiliesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FamiliesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGenresResponse parses an HTTP response from a ListGenresWithResponse call
func ParseListGenresResponse(rsp *http.Response) (*ListGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenresListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListGameInfoTypesResponse parses an HTTP response from a ListGameInfoTypesWithResponse call
func ParseListGameInfoTypesResponse(rsp *http.Response) (*ListGameInfoTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGameInfoTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameInfoTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRomInfoTypesResponse parses an HTTP response from a ListRomInfoTypesWithResponse call
func ParseListRomInfoTypesResponse(rsp *http.Response) (*ListRomInfoTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRomInfoTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RomInfoTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGameInfoResponse parses an HTTP response from a GetGameInfoWithResponse call
func ParseGetGameInfoResponse(rsp *http.Response) (*GetGameInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGameInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchGamesResponse parses an HTTP response from a SearchGamesWithResponse call
func ParseSearchGamesResponse(rsp *http.Response) (*SearchGamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLanguagesResponse parses an HTTP response from a ListLanguagesWithResponse call
func ParseListLanguagesResponse(rsp *http.Response) (*ListLanguagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LanguagesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadCompanyMediaResponse parses an HTTP response from a DownloadCompanyMediaWithResponse call
func ParseDownloadCompanyMediaResponse(rsp *http.Response) (*DownloadCompanyMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadCompanyMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadGroupMediaResponse parses an HTTP response from a DownloadGroupMediaWithResponse call
func ParseDownloadGroupMediaResponse(rsp *http.Response) (*DownloadGroupMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGroupMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadGameMediaResponse parses an HTTP response from a DownloadGameMediaWithResponse call
func ParseDownloadGameMediaResponse(rsp *http.Response) (*DownloadGameMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadGameMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDownloadSystemMediaResponse parses an HTTP response from a DownloadSystemMediaWithResponse call
func ParseDownloadSystemMediaResponse(rsp *http.Response) (*DownloadSystemMediaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadSystemMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListGameMediaTypesResponse parses an HTTP response from a ListGameMediaTypesWithResponse call
func ParseListGameMediaTypesResponse(rsp *http.Response) (*ListGameMediaTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGameMediaTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GameMediaTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSystemMediaTypesResponse parses an HTTP response from a ListSystemMediaTypesWithResponse call
func ParseListSystemMediaTypesResponse(rsp *http.Response) (*ListSystemMediaTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSystemMediaTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemMediaTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPlayerCountsResponse parses an HTTP response from a ListPlayerCountsWithResponse call
func ParseListPlayerCountsResponse(rsp *http.Response) (*ListPlayerCountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlayerCountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlayerCountsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRegionsResponse parses an HTTP response from a ListRegionsWithResponse call
func ParseListRegionsResponse(rsp *http.Response) (*ListRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegionsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRomTypesResponse parses an HTTP response from a ListRomTypesWithResponse call
func ParseListRomTypesResponse(rsp *http.Response) (*ListRomTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRomTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RomTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInfraInfoResponse parses an HTTP response from a GetInfraInfoWithResponse call
func ParseGetInfraInfoResponse(rsp *http.Response) (*GetInfraInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfraInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InfraInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserInfoResponse parses an HTTP response from a GetUserInfoWithResponse call
func ParseGetUserInfoResponse(rsp *http.Response) (*GetUserInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSupportTypesResponse parses an HTTP response from a ListSupportTypesWithResponse call
func ParseListSupportTypesResponse(rsp *http.Response) (*ListSupportTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSupportTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportTypesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSystemsResponse parses an HTTP response from a ListSystemsWithResponse call
func ParseListSystemsResponse(rsp *http.Response) (*ListSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SystemsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListUserLevelsResponse parses an HTTP response from a ListUserLevelsWithResponse call
func ParseListUserLevelsResponse(rsp *http.Response) (*ListUserLevelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserLevelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserLevelsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
